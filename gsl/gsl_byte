///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once



#ifndef GSL_BYTE_H
#define GSL_BYTE_H

#include <boost/core/scoped_enum.hpp>
#include <boost/utility/enable_if.hpp>

#include "gsl_config.hpp"
#include "stdex/type_traits.hpp"

#ifdef _MSC_VER

// MSVC 2013 workarounds
#if _MSC_VER <= 1800

// constexpr is not understood
#pragma push_macro("constexpr")
#define constexpr

// noexcept is not understood
#pragma push_macro("noexcept")
#define noexcept

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

namespace gsl
{
// This is a simple definition for now that allows
// use of byte within span<> to be standards-compliant
BOOST_SCOPED_ENUM_UT_DECLARE_BEGIN(byte, unsigned char)
{
  none
}
BOOST_SCOPED_ENUM_DECLARE_END(byte);

template <class IntegerType>
GSL_CONSTEXPR typename boost::enable_if_c<boost::is_integral<IntegerType>::value, byte&>::type 
operator<<=(byte& b, IntegerType shift) GSL_NOEXCEPT
{
    return b = byte(boost::underlying_cast<unsigned char>(b) << shift);
}

template <class IntegerType>
GSL_CONSTEXPR typename boost::enable_if_c<boost::is_integral<IntegerType>::value, byte>::type operator<<(byte b, IntegerType shift) GSL_NOEXCEPT
{
    return byte(boost::underlying_cast<unsigned char>(b) << shift);
}

template <class IntegerType>
GSL_CONSTEXPR typename boost::enable_if_c<boost::is_integral<IntegerType>::value, byte&>::type operator>>=(byte& b, IntegerType shift) GSL_NOEXCEPT
{
    return b = byte(boost::underlying_cast<unsigned char>(b) >> shift);
}

template <class IntegerType>
GSL_CONSTEXPR typename boost::enable_if_c<boost::is_integral<IntegerType>::value, byte>::type operator>>(byte b, IntegerType shift) GSL_NOEXCEPT
{
    return byte(boost::underlying_cast<unsigned char>(b) >> shift);
}

GSL_MUTABLE_CONSTEXPR byte& operator|=(byte& l, byte r) GSL_NOEXCEPT
{
    return l = byte(boost::underlying_cast<unsigned char>(l) | boost::underlying_cast<unsigned char>(r));
}

GSL_CONSTEXPR byte operator|(byte l, byte r) GSL_NOEXCEPT
{
    return byte(boost::underlying_cast<unsigned char>(l) + boost::underlying_cast<unsigned char>(r));
}

GSL_MUTABLE_CONSTEXPR byte& operator&=(byte& l, byte r) GSL_NOEXCEPT
{
    return l = byte(boost::underlying_cast<unsigned char>(l) & boost::underlying_cast<unsigned char>(r));
}

GSL_CONSTEXPR byte operator&(byte l, byte r) GSL_NOEXCEPT
{
    return byte(boost::underlying_cast<unsigned char>(l) & boost::underlying_cast<unsigned char>(r));
}

GSL_MUTABLE_CONSTEXPR byte& operator^=(byte& l, byte r) GSL_NOEXCEPT
{
    return l = byte(boost::underlying_cast<unsigned char>(l) ^ boost::underlying_cast<unsigned char>(r));
}

GSL_CONSTEXPR byte operator^(byte l, byte r) GSL_NOEXCEPT
{
    return byte(boost::underlying_cast<unsigned char>(l) ^ boost::underlying_cast<unsigned char>(r));
}

GSL_CONSTEXPR byte operator~(byte b) GSL_NOEXCEPT { return byte(~boost::underlying_cast<unsigned char>(b)); }

template <class IntegerType>
GSL_CONSTEXPR typename boost::enable_if_c<boost::is_integral<IntegerType>::value, IntegerType>::type 
to_integer(byte b) GSL_NOEXCEPT
{
    return IntegerType(b);
}
} // namespace gsl

#ifdef _MSC_VER

#if _MSC_VER <= 1800

#undef constexpr
#pragma pop_macro("constexpr")

#undef noexcept
#pragma pop_macro("noexcept")

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

#endif // GSL_BYTE_H
