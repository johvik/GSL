
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_SPAN_H
#define GSL_SPAN_H

#include "gsl_config.hpp"
#include <boost/type_traits.hpp>
#include "boost/static_assert.hpp"

#include "stdex/type_traits.hpp"
#include "stdex/algorithm.hpp"

#include "gsl_assert"
#include "gsl_byte"
#include "gsl_util"
#if __cplusplus > 201102L
#include <array>
#else
#include <boost/array.hpp>
#endif

#include <iterator>
#include <limits>
#include <stdexcept>
#if __cplusplus > 201102L
#include <type_traits>
#else
#include <boost/type_traits.hpp>
#endif
#include <utility>
#include <boost/move/move.hpp>

#ifdef _MSC_VER

#pragma warning(push)

// turn off some warnings that are noisy about our Expects statements
#pragma warning(disable : 4127) // conditional expression is constant

// blanket turn off warnings from CppCoreCheck for now
// so people aren't annoyed by them when running the tool.
// more targeted suppressions will be added in a future update to the GSL
#pragma warning(disable : 26481 26482 26483 26485 26490 26491 26492 26493 26495)

// No MSVC does constexpr fully yet
#pragma push_macro("constexpr")
#define constexpr

// VS 2013 workarounds
#if _MSC_VER <= 1800

#define GSL_MSVC_HAS_VARIADIC_CTOR_BUG
#define GSL_MSVC_NO_DEFAULT_MOVE_CTOR
#define GSL_MSVC_NO_CPP14_STD_EQUAL

// noexcept is not understood
#ifndef GSL_THROW_ON_CONTRACT_VIOLATION
#pragma push_macro("noexcept")
#define noexcept /* nothing */
#endif

#pragma push_macro("alignof")
#define alignof __alignof

// turn off some misguided warnings
#pragma warning(push)
#pragma warning(disable : 4351) // warns about newly introduced aggregate initializer behavior
#pragma warning(disable : 4512) // warns that assignment op could not be generated

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

#ifdef GSL_THROW_ON_CONTRACT_VIOLATION

#ifdef _MSC_VER
#pragma push_macro("noexcept")
#endif

#define noexcept /* nothing */

#endif // GSL_THROW_ON_CONTRACT_VIOLATION

namespace gsl
{

// [views.constants], constants
GSL_CONSTEXPR const std::ptrdiff_t dynamic_extent = -1;

template <class ElementType, std::ptrdiff_t Extent = dynamic_extent>
class span;

// implementation details
namespace details
{
    template <class T>
    struct is_span_oracle : boost::false_type
    {
    };

    template <class ElementType, std::ptrdiff_t Extent>
    struct is_span_oracle<gsl::span<ElementType, Extent> > : boost::true_type
    {
    };

    template <class T>
    struct is_span : public is_span_oracle<typename boost::remove_cv<T>::type >
    {
    };

    template <class T>
    struct is_std_array_oracle : boost::false_type
    {
    };

    template <class ElementType, size_t Extent>
    struct is_std_array_oracle<boost::array<ElementType, Extent> > : boost::true_type
    {
    };

    template <class T>
    struct is_std_array : public is_std_array_oracle<typename boost::remove_cv<T>::type >
    {
    };

    template <class From, class To>
    struct is_allowed_pointer_conversion
        : public boost::integral_constant<bool, boost::is_pointer<From>::value &&
                                                  boost::is_pointer<To>::value &&
                                                  boost::is_convertible<From, To>::value>
    {
    };

    template <class From, class To>
    struct is_allowed_integral_conversion
        : public boost::integral_constant<
              bool, boost::is_integral<From>::value && boost::is_integral<To>::value &&
                        sizeof(From) == sizeof(To) && GSL_ALIGNOF(From) == GSL_ALIGNOF(To) &&
                        boost::is_convertible<From, To>::value>
    {
    };

    template <std::ptrdiff_t From, std::ptrdiff_t To>
    struct is_allowed_extent_conversion
        : public boost::integral_constant<bool, From == To || From == gsl::dynamic_extent ||
                                                  To == gsl::dynamic_extent>
    {
    };

    template <class From, class To>
    struct is_allowed_element_type_conversion
        : public boost::integral_constant<bool, boost::is_same<From, typename boost::remove_cv<To>::type >::value ||
                                                  is_allowed_pointer_conversion<From, To>::value ||
                                                  is_allowed_integral_conversion<From, To>::value>
    {
    };

    template <class From>
    struct is_allowed_element_type_conversion<From, byte>
        : public boost::integral_constant<bool, !boost::is_const<From>::value>
    {
    };

    template <class From>
    struct is_allowed_element_type_conversion<From, const byte> : public boost::true_type
    {
    };

    template <class Span, bool IsConst>
    class span_iterator
    {
    public:
        typedef std::random_access_iterator_tag iterator_category ;
        typedef  
            typename boost::conditional<IsConst, typename boost::add_const<typename Span::element_type>::type,
                               typename Span::element_type>::type value_type;
        typedef typename Span::index_type difference_type;

        typedef typename boost::add_pointer<value_type>::type pointer;
        typedef typename boost::add_lvalue_reference<value_type>::type reference;

        GSL_CONSTEXPR span_iterator() GSL_NOEXCEPT
#if __cplusplus > 201102L
         : span_iterator(nullptr, 0) {}
#else
            : span_(0), index_(0) {}
#endif         

        GSL_CONTRACT_CONSTEXPR span_iterator(const Span* span, typename Span::index_type index)
            : span_(span), index_(index)
        {
            Expects(span == nullptr || (index_ >= 0 && index <= span_->length()));
        }

        friend class span_iterator<Span, true>;
        GSL_CONSTEXPR span_iterator(const span_iterator<Span, false>& other) GSL_NOEXCEPT
#if __cplusplus > 201102L
            : span_iterator(other.span_, other.index_)
        {
        }
#else
            : span_(other.span_), index_(other.index_) {}
#endif         

        GSL_CONTRACT_CONSTEXPR reference operator*() const
        {
            Expects(span_);
            return (*span_)[index_];
        }

        GSL_CONTRACT_CONSTEXPR pointer operator->() const
        {
            Expects(span_);
            return &((*span_)[index_]);
        }

        GSL_MUTABLE_CONSTEXPR span_iterator& operator++() GSL_NOEXCEPT
        {
            Expects(span_ && index_ >= 0 && index_ < span_->length());
            ++index_;
            return *this;
        }

        GSL_MUTABLE_CONSTEXPR span_iterator operator++(int) GSL_NOEXCEPT
        {
            span_iterator ret = *this;
            ++(*this);
            return ret;
        }

        GSL_MUTABLE_CONSTEXPR span_iterator& operator--() GSL_NOEXCEPT
        {
            Expects(span_ && index_ > 0 && index_ <= span_->length());
            --index_;
            return *this;
        }

        GSL_MUTABLE_CONSTEXPR span_iterator operator--(int) GSL_NOEXCEPT
        {
            span_iterator ret = *this;
            --(*this);
            return ret;
        }

        GSL_CXX14_CONSTEXPR span_iterator operator+(difference_type n) const GSL_NOEXCEPT
        {
            span_iterator ret = *this;
            return ret += n;
        }

        GSL_MUTABLE_CONSTEXPR span_iterator& operator+=(difference_type n) GSL_NOEXCEPT
        {
            Expects(span_ && (index_ + n) >= 0 && (index_ + n) <= span_->length());
            index_ += n;
            return *this;
        }

        GSL_CXX14_CONSTEXPR span_iterator operator-(difference_type n) const GSL_NOEXCEPT
        {
            span_iterator ret = *this;
            return ret -= n;
        }

        GSL_MUTABLE_CONSTEXPR span_iterator& operator-=(difference_type n) GSL_NOEXCEPT { return *this += -n; }

        GSL_CONTRACT_CONSTEXPR difference_type operator-(const span_iterator& rhs) const GSL_NOEXCEPT
        {
            Expects(span_ == rhs.span_);
            return index_ - rhs.index_;
        }

        GSL_CONSTEXPR reference operator[](difference_type n) const GSL_NOEXCEPT { return *(*this + n); }

        GSL_CONSTEXPR friend bool operator==(const span_iterator& lhs,
                                         const span_iterator& rhs) GSL_NOEXCEPT
        {
            return lhs.span_ == rhs.span_ && lhs.index_ == rhs.index_;
        }

        GSL_CONSTEXPR friend bool operator!=(const span_iterator& lhs,
                                         const span_iterator& rhs) GSL_NOEXCEPT
        {
            return !(lhs == rhs);
        }

        GSL_CONTRACT_CONSTEXPR friend bool operator<(const span_iterator& lhs, const span_iterator& rhs) GSL_NOEXCEPT
        {
            Expects(lhs.span_ == rhs.span_);
            return lhs.index_ < rhs.index_;
        }

        GSL_CONSTEXPR friend bool operator<=(const span_iterator& lhs,
                                         const span_iterator& rhs) GSL_NOEXCEPT
        {
            return !(rhs < lhs);
        }

        GSL_CONSTEXPR friend bool operator>(const span_iterator& lhs, const span_iterator& rhs) GSL_NOEXCEPT
        {
            return rhs < lhs;
        }

        GSL_CONSTEXPR friend bool operator>=(const span_iterator& lhs,
                                         const span_iterator& rhs) GSL_NOEXCEPT
        {
            return !(rhs > lhs);
        }

        void swap(span_iterator& rhs) GSL_NOEXCEPT
        {
            std::swap(index_, rhs.index_);
            std::swap(span_, rhs.span_);
        }

    protected:
        const Span* span_;
        std::ptrdiff_t index_;
    };

    template <class Span, bool IsConst>
    GSL_CONSTEXPR span_iterator<Span, IsConst>
    operator+(typename span_iterator<Span, IsConst>::difference_type n,
              const span_iterator<Span, IsConst>& rhs) GSL_NOEXCEPT
    {
        return rhs + n;
    }

    template <class Span, bool IsConst>
    GSL_CONSTEXPR span_iterator<Span, IsConst>
    operator-(typename span_iterator<Span, IsConst>::difference_type n,
              const span_iterator<Span, IsConst>& rhs) GSL_NOEXCEPT
    {
        return rhs - n;
    }

    template <std::ptrdiff_t Ext>
    class extent_type
    {
    public:
        typedef std::ptrdiff_t index_type;

        BOOST_STATIC_ASSERT_MSG(Ext >= 0, "A fixed-size span must be >= 0 in size.");

        GSL_CONSTEXPR extent_type() GSL_NOEXCEPT {}

        template <index_type Other>
        GSL_CONTRACT_CONSTEXPR extent_type(extent_type<Other> ext) GSL_NOEXCEPT
        {
            BOOST_STATIC_ASSERT_MSG(Other == Ext || Other == dynamic_extent,
                          "Mismatch between fixed-size extent and size of initializing data.");
            Expects(ext.size() == Ext);
        }

        GSL_CONTRACT_CONSTEXPR extent_type(index_type size) { Expects(size == Ext); }

        GSL_CONSTEXPR inline index_type size() const GSL_NOEXCEPT { return Ext; }
    };

    template <>
    class extent_type<dynamic_extent>
    {
    public:
        typedef std::ptrdiff_t index_type;

        template <index_type Other>
        explicit GSL_CONSTEXPR extent_type(extent_type<Other> ext) : size_(ext.size())
        {
        }

        explicit GSL_CONTRACT_CONSTEXPR extent_type(index_type size) : size_(size) { Expects(size >= 0); }

        GSL_CONSTEXPR inline index_type size() const GSL_NOEXCEPT { return size_; }

    private:
        index_type size_;
    };
} // namespace details

// [span], class template span
template <class ElementType, std::ptrdiff_t Extent>
class span
{
#if defined BOOST_NO_CXX11_RVALUE_REFERENCES
  BOOST_COPYABLE_AND_MOVABLE(span)
#endif
public:
    // constants and types
    typedef ElementType element_type;
    typedef std::ptrdiff_t index_type;
    typedef element_type* pointer;
    typedef element_type& reference;

    typedef details::span_iterator<span<ElementType, Extent>, false> iterator;
    typedef details::span_iterator<span<ElementType, Extent>, true> const_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    GSL_CONSTEXPR static const index_type extent = Extent;

    // [span.cons], span constructors, copy, assignment, and destructor
    GSL_CONSTEXPR span() GSL_NOEXCEPT : storage_(nullptr, details::extent_type<0>()) {}

//fixme
#if ! defined BOOST_NO_CXX11_NULLPTR   
    GSL_CONSTEXPR span(std::nullptr_t) GSL_NOEXCEPT : span() {}
#endif
    GSL_CONSTEXPR span(pointer ptr, index_type count) : storage_(ptr, count) {}

    GSL_CONSTEXPR span(pointer firstElem, pointer lastElem)
        : storage_(firstElem, std::distance(firstElem, lastElem))
    {
    }

    template <size_t N>
    GSL_CONSTEXPR span(element_type (&arr)[N]) GSL_NOEXCEPT : storage_(&arr[0], details::extent_type<N>())
    {
    }
#if 0    
    template <size_t N>
    GSL_CONSTEXPR span(typename boost::remove_const<element_type>::type (&arr)[N]) GSL_NOEXCEPT : storage_(&arr[0], details::extent_type<N>())
    {
    }
#endif    
//fixme
    template <size_t N, class ArrayElementType >
    GSL_CONSTEXPR span(boost::array<ArrayElementType, N>& arr) GSL_NOEXCEPT
        : storage_(&arr[0], details::extent_type<N>())
    {
    }
    template <size_t N >
    GSL_CONSTEXPR span(boost::array<typename boost::remove_const<element_type>::type, N>& arr) GSL_NOEXCEPT
        : storage_(&arr[0], details::extent_type<N>())
    {
    }

    template <size_t N>
    GSL_CONSTEXPR span(const boost::array<typename boost::remove_const<element_type>::type, N>& arr) GSL_NOEXCEPT
        : storage_(&arr[0], details::extent_type<N>())
    {
    }

    // NB: the SFINAE here uses .data() as a incomplete/imperfect proxy for the requirement
    // on Container to be a contiguous sequence container.
    template <class Container>  
    GSL_CONSTEXPR span(Container& cont,
    typename boost::enable_if_c<
                  !details::is_span<Container>::value && !details::is_std_array<Container>::value &&
                  boost::is_convertible<typename Container::pointer, pointer>::value
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
                  &&
                  boost::is_convertible<typename Container::pointer,
                                      decltype(boost::declval<Container>().data())>::value> 
#endif                                      
                      >::type* = 0

    ) 
    : storage_(cont.data(), cont.size())
    {
    }

    template <class Container>
    GSL_CONSTEXPR span(const Container& cont,
              typename boost::enable_if_c<
                  boost::is_const<element_type>::value && !details::is_span<Container>::value &&
                  boost::is_convertible<typename Container::pointer, pointer>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
                  &&
                  boost::is_convertible<typename Container::pointer,
                                      decltype(boost::declval<Container>().data())>::value> 
#endif                                      
                      >::type * = 0    
    ) : storage_(cont.data(), cont.size())
    {
    }

    BOOST_DEFAULTED_FUNCTION( GSL_CONSTEXPR span(const span& other) GSL_NOEXCEPT, 
      : storage_(other.storage_){});
#if defined BOOST_NO_CXX11_RVALUE_REFERENCES      
    GSL_CONSTEXPR span( BOOST_RV_REF(span) other) GSL_NOEXCEPT 
      : storage_(boost::move(other.storage_)) {}
#endif

    template <
        class OtherElementType, std::ptrdiff_t OtherExtent>
    GSL_CONSTEXPR span(const span<OtherElementType, OtherExtent>& other,
    typename boost::enable_if_c<
            details::is_allowed_extent_conversion<OtherExtent, Extent>::value &&
            details::is_allowed_element_type_conversion<OtherElementType, element_type>::value>::type* =0)
        : storage_(reinterpret_cast<pointer>(other.data()),
                   details::extent_type<OtherExtent>(other.size()))
    {
    }

#if defined BOOST_NO_CXX11_RVALUE_REFERENCES      
    template <
        class OtherElementType, std::ptrdiff_t OtherExtent>
    GSL_CONSTEXPR span( BOOST_RV_REF_BEG span<OtherElementType, OtherExtent> BOOST_RV_REF_END other,
          typename boost::enable_if_c<
            details::is_allowed_extent_conversion<OtherExtent, Extent>::value &&
            details::is_allowed_element_type_conversion<OtherElementType, element_type>::value
          >::type* = 0
        )
        : storage_(reinterpret_cast<pointer>(other.data()),
                   details::extent_type<OtherExtent>(other.size()))
    {
    }
#endif

    BOOST_DEFAULTED_FUNCTION( ~span() GSL_NOEXCEPT, {});
    
#if ! defined BOOST_NO_CXX11_RVALUE_REFERENCES
    GSL_DEFAULT_CONSTEXPR span& operator=( const span& other) GSL_NOEXCEPT {
      storage_= other.storage_;
      return *this;
    };
#else
    GSL_DEFAULT_CONSTEXPR span& operator=( BOOST_COPY_ASSIGN_REF(span) other) GSL_NOEXCEPT {
      storage_= other.storage_;
      return *this;
    };
#endif

    GSL_CONSTEXPR span& operator=(BOOST_RV_REF(span) other) GSL_NOEXCEPT
    {
        storage_ = boost::move(other.storage_);
        return *this;
    }
    
    // [span.sub], span subviews
    template <std::ptrdiff_t Count>
    GSL_CONTRACT_CONSTEXPR span<element_type, Count> first() const
    {
        Expects(Count >= 0 && Count <= size());
        return span<element_type, Count>(data(), Count);
    }

    template <std::ptrdiff_t Count>
    GSL_CONTRACT_CONSTEXPR span<element_type, Count> last() const
    {
        Expects(Count >= 0 && Count <= size());
        return span<element_type, Count>(data() + (size() - Count), Count);
    }

    template <std::ptrdiff_t Offset, std::ptrdiff_t Count>
    GSL_CONTRACT_CONSTEXPR span<element_type, Count> subspan() const
    {
        Expects((Offset == 0 || (Offset > 0 && Offset <= size())) &&
                (Count == dynamic_extent || (Count >= 0 && Offset + Count <= size())));
        return span<element_type, Count>(data() + Offset, Count == dynamic_extent ? size() - Offset : Count);
    }

    template <std::ptrdiff_t Offset>
    GSL_CONTRACT_CONSTEXPR span<element_type, dynamic_extent> subspan() const
    {
        const std::ptrdiff_t Count = dynamic_extent;
        Expects((Offset == 0 || (Offset > 0 && Offset <= size())) &&
                (Count == dynamic_extent || (Count >= 0 && Offset + Count <= size())));
        return span<element_type, dynamic_extent>(data() + Offset, Count == dynamic_extent ? size() - Offset : Count);
    }

    GSL_CONTRACT_CONSTEXPR span<element_type, dynamic_extent> first(index_type count) const
    {
        Expects(count >= 0 && count <= size());
        return span<element_type, dynamic_extent>(data(), count);
    }

    GSL_CONTRACT_CONSTEXPR span<element_type, dynamic_extent> last(index_type count) const
    {
        Expects(count >= 0 && count <= size());
        return span<element_type, dynamic_extent>(data() + (size() - count), count);
    }

    GSL_CONTRACT_CONSTEXPR span<element_type, dynamic_extent> subspan(index_type offset,
                                                         index_type count = dynamic_extent) const
    {
        Expects((offset == 0 || (offset > 0 && offset <= size())) &&
                (count == dynamic_extent || (count >= 0 && offset + count <= size())));
        return span<element_type, dynamic_extent>(data() + offset, count == dynamic_extent ? size() - offset : count);
    }

    // [span.obs], span observers
    GSL_CONSTEXPR index_type length() const GSL_NOEXCEPT { return size(); }
    GSL_CONSTEXPR index_type size() const GSL_NOEXCEPT { return storage_.size(); }
    GSL_CONSTEXPR index_type length_bytes() const GSL_NOEXCEPT { return size_bytes(); }
    GSL_CONSTEXPR index_type size_bytes() const GSL_NOEXCEPT { return size() * sizeof(element_type); }
    GSL_CONSTEXPR bool empty() const GSL_NOEXCEPT { return size() == 0; }

    // [span.elem], span element access
    GSL_CONTRACT_CONSTEXPR reference operator[](index_type idx) const
    {
        Expects(idx >= 0 && idx < storage_.size());
        return data()[idx];
    }
    GSL_CONSTEXPR reference operator()(index_type idx) const { return this->operator[](idx); }
    GSL_CONSTEXPR pointer data() const GSL_NOEXCEPT { return storage_.data(); }

    // [span.iter], span iterator support
    iterator begin() const GSL_NOEXCEPT { return iterator(this, 0); }
    iterator end() const GSL_NOEXCEPT { return iterator(this, length()); }

    const_iterator cbegin() const GSL_NOEXCEPT { return const_iterator(this, 0); }
    const_iterator cend() const GSL_NOEXCEPT { return const_iterator(this, length()); }

    reverse_iterator rbegin() const GSL_NOEXCEPT { return reverse_iterator(end()); }
    reverse_iterator rend() const GSL_NOEXCEPT { return reverse_iterator(begin()); }

    const_reverse_iterator crbegin() const GSL_NOEXCEPT { return const_reverse_iterator(cend()); }
    const_reverse_iterator crend() const GSL_NOEXCEPT { return const_reverse_iterator(cbegin()); }

private:
    // this implementation detail class lets us take advantage of the
    // empty base class optimization to pay for only storage of a single
    // pointer in the case of fixed-size spans
    template <class ExtentType>
    class storage_type : public ExtentType
    {
    public:
        template <class OtherExtentType>
        GSL_CONTRACT_CONSTEXPR storage_type(pointer data, OtherExtentType ext) : ExtentType(ext), data_(data)
        {
            Expects((!data && ExtentType::size() == 0) || (data && ExtentType::size() >= 0));
        }

        GSL_CONSTEXPR inline pointer data() const GSL_NOEXCEPT { return data_; }

    private:
        pointer data_;
    };

    storage_type<details::extent_type<Extent> > storage_;
};

// [span.comparison], span comparison operators
template <class ElementType, std::ptrdiff_t FirstExtent, std::ptrdiff_t SecondExtent>
GSL_CONSTEXPR bool operator==(const span<ElementType, FirstExtent>& l,
                          const span<ElementType, SecondExtent>& r)
{
#ifdef GSL_MSVC_NO_CPP14_STD_EQUAL
    return (l.size() == r.size()) && std::equal(l.begin(), l.end(), r.begin());
#else
    return stdex::equal(l.begin(), l.end(), r.begin(), r.end());
#endif
}

template <class ElementType, std::ptrdiff_t Extent>
GSL_CONSTEXPR bool operator!=(const span<ElementType, Extent>& l, const span<ElementType, Extent>& r)
{
    return !(l == r);
}

template <class ElementType, std::ptrdiff_t Extent>
GSL_CONSTEXPR bool operator<(const span<ElementType, Extent>& l, const span<ElementType, Extent>& r)
{
    return std::lexicographical_compare(l.begin(), l.end(), r.begin(), r.end());
}

template <class ElementType, std::ptrdiff_t Extent>
GSL_CONSTEXPR bool operator<=(const span<ElementType, Extent>& l, const span<ElementType, Extent>& r)
{
    return !(l > r);
}

template <class ElementType, std::ptrdiff_t Extent>
GSL_CONSTEXPR bool operator>(const span<ElementType, Extent>& l, const span<ElementType, Extent>& r)
{
    return r < l;
}

template <class ElementType, std::ptrdiff_t Extent>
GSL_CONSTEXPR bool operator>=(const span<ElementType, Extent>& l, const span<ElementType, Extent>& r)
{
    return !(l < r);
}

namespace details
{
    // if we only supported compilers with good constexpr support then
    // this pair of classes could collapse down to a constexpr function

    // we should use a narrow_cast<> to go to size_t, but older compilers may not see it as
    // constexpr
    // and so will fail compilation of the template
    template <class ElementType, std::ptrdiff_t Extent>
    struct calculate_byte_size
        : boost::integral_constant<std::ptrdiff_t,
                                 static_cast<std::ptrdiff_t>(sizeof(ElementType) *
                                                             static_cast<std::size_t>(Extent))>
    {
    };

    template <class ElementType>
    struct calculate_byte_size<ElementType, dynamic_extent>
        : boost::integral_constant<std::ptrdiff_t, dynamic_extent>
    {
    };
}

// [span.objectrep], views of object representation
template <class ElementType, std::ptrdiff_t Extent>
span<const byte, details::calculate_byte_size<ElementType, Extent>::value>
as_bytes(span<ElementType, Extent> s) GSL_NOEXCEPT
{
    typedef span<const byte, details::calculate_byte_size<ElementType, Extent>::value> result_type;
    return result_type(reinterpret_cast<const byte*>(s.data()), s.size_bytes());
}

template <class ElementType, std::ptrdiff_t Extent>         
typename boost::enable_if_c<!boost::is_const<ElementType>::value,
  span<byte, details::calculate_byte_size<ElementType, Extent>::value>
>::type 
as_writeable_bytes(span<ElementType, Extent> s) GSL_NOEXCEPT
{
    typedef span<byte, details::calculate_byte_size<ElementType, Extent>::value> result_type;
    return result_type(reinterpret_cast<byte*>(s.data()), s.size_bytes());
}

} // namespace gsl

#ifdef _MSC_VER

#undef constexpr
#pragma pop_macro("constexpr")

#if _MSC_VER <= 1800
#pragma warning(pop)

#ifndef GSL_THROW_ON_CONTRACT_VIOLATION
#undef noexcept
#pragma pop_macro("noexcept")
#endif // GSL_THROW_ON_CONTRACT_VIOLATION

#pragma pop_macro("alignof")

#undef GSL_MSVC_HAS_VARIADIC_CTOR_BUG

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

#if defined(GSL_THROW_ON_CONTRACT_VIOLATION)

#undef noexcept

#ifdef _MSC_VER
#pragma pop_macro("noexcept")
#endif

#endif // GSL_THROW_ON_CONTRACT_VIOLATION

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif // GSL_SPAN_H
