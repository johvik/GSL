///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_STRING_SPAN_H
#define GSL_STRING_SPAN_H

#include "gsl_config.hpp"

#include "gsl_assert"
#include "gsl_util"
#include "span"

#include "stdex/type_traits.hpp"
#include "stdex/algorithm.hpp"

#include <boost/move/move.hpp>
#include <boost/type_traits.hpp>

//#include <cstdint>
#include <cstring>
#include <string>


#ifdef _MSC_VER

// No MSVC does constexpr fully yet
#pragma push_macro("constexpr")
#define constexpr /*constexpr*/

#pragma warning(push)

// blanket turn off warnings from CppCoreCheck for now
// so people aren't annoyed by them when running the tool.
// more targeted suppressions will be added in a future update to the GSL
#pragma warning(disable : 26481 26482 26483 26485 26490 26491 26492 26493 26495)

// VS 2013 workarounds
#if _MSC_VER <= 1800

#define GSL_MSVC_HAS_TYPE_DEDUCTION_BUG
#define GSL_MSVC_HAS_SFINAE_SUBSTITUTION_ICE
#define GSL_MSVC_NO_CPP14_STD_EQUAL
#define GSL_MSVC_NO_DEFAULT_MOVE_CTOR

// noexcept is not understood
#ifndef GSL_THROW_ON_CONTRACT_VIOLATION
#pragma push_macro("noexcept")
#define noexcept /*noexcept*/
#endif

#endif // _MSC_VER <= 1800
#endif // _MSC_VER

// In order to test the library, we need it to throw exceptions that we can catch
#ifdef GSL_THROW_ON_CONTRACT_VIOLATION

#ifdef _MSC_VER
#pragma push_macro("noexcept")
#endif

//#define noexcept /*noexcept*/

#endif // GSL_THROW_ON_CONTRACT_VIOLATION

namespace gsl
{
//
// czstring and wzstring
//
// These are "tag" typedef's for C-style strings (i.e. null-terminated character arrays)
// that allow static analysis to help find bugs.
//
// There are no additional features/semantics that we can find a way to add inside the
// type system for these types that will not either incur significant runtime costs or
// (sometimes needlessly) break existing programs when introduced.
//

#if ! defined BOOST_NO_CXX11_TEMPLATE_ALIASES
template <typename CharT, std::ptrdiff_t Extent = dynamic_extent>
using basic_zstring = CharT*;

template <std::ptrdiff_t Extent = dynamic_extent>
using czstring = basic_zstring<const char, Extent>;

template <std::ptrdiff_t Extent = dynamic_extent>
using cwzstring = basic_zstring<const wchar_t, Extent>;

template <std::ptrdiff_t Extent = dynamic_extent>
using zstring = basic_zstring<char, Extent>;

template <std::ptrdiff_t Extent = dynamic_extent>
using wzstring = basic_zstring<wchar_t, Extent>;

#else

template <typename CharT, std::ptrdiff_t Extent = dynamic_extent>
struct basic_zstring { typedef CharT* type; };

template <std::ptrdiff_t Extent = dynamic_extent>
struct czstring { typedef typename basic_zstring<const char, Extent>::type type; };

template <std::ptrdiff_t Extent = dynamic_extent>
struct cwzstring { typedef typename basic_zstring<const wchar_t, Extent>::type type; };

template <std::ptrdiff_t Extent = dynamic_extent>
struct zstring { typedef typename basic_zstring<char, Extent>::type type; };

template <std::ptrdiff_t Extent = dynamic_extent>
struct wzstring { typedef typename basic_zstring<wchar_t, Extent>::type type; };

#endif
namespace details
{
    inline std::ptrdiff_t string_length(const char *str, std::ptrdiff_t n)
    {
        if (str == nullptr || n <= 0)
            return 0;

        span<const char> str_span(str, n);

        std::ptrdiff_t len = 0;
        while (len < n && str_span[len])
            len++;

        return len;
    }

    inline std::ptrdiff_t wstring_length(const wchar_t *str, std::ptrdiff_t n)
    {
        if (str == nullptr || n <= 0)
            return 0;

        span<const wchar_t> str_span(str, n);

        std::ptrdiff_t len = 0;
        while (len < n && str_span[len])
            len++;

        return len;
    }
}


//
// ensure_sentinel()
//
// Provides a way to obtain an span from a contiguous sequence
// that ends with a (non-inclusive) sentinel value.
//
// Will fail-fast if sentinel cannot be found before max elements are examined.
//
template <typename T, const T Sentinel>
span<T, dynamic_extent> ensure_sentinel(T* seq, std::ptrdiff_t max = PTRDIFF_MAX)
{
    T* cur = seq;
    while ((cur - seq) < max && *cur != Sentinel) ++cur;
    Ensures(*cur == Sentinel);
    return span<T, dynamic_extent>(seq, cur - seq);
}

//
// ensure_z - creates a span for a czstring or cwzstring.
// Will fail fast if a null-terminator cannot be found before
// the limit of size_type.
//
template <typename T>
inline span<T, dynamic_extent> ensure_z(T* const& sz, std::ptrdiff_t max = PTRDIFF_MAX)
{
    return ensure_sentinel<T, 0>(sz, max);
}

// TODO (neilmac) there is probably a better template-magic way to get the const and non-const
// overloads to share an implementation
inline span<char, dynamic_extent> ensure_z(char* const& sz, std::ptrdiff_t max)
{
    auto len = details::string_length(sz, max);
    Ensures(sz[len] == 0);
    return span<char, dynamic_extent>(sz, len);
}

inline span<const char, dynamic_extent> ensure_z(const char* const& sz, std::ptrdiff_t max)
{
    std::size_t len = details::string_length(sz, max);
    Ensures(sz[len] == 0);
    return span<const char, dynamic_extent>(sz, len);
}

inline span<wchar_t, dynamic_extent> ensure_z(wchar_t* const& sz, std::ptrdiff_t max)
{
    std::size_t len = details::wstring_length(sz, max);
    Ensures(sz[len] == 0);
    return span<wchar_t, dynamic_extent>(sz, len);
}

inline span<const wchar_t, dynamic_extent> ensure_z(const wchar_t* const& sz, std::ptrdiff_t max)
{
    std::size_t len = details::wstring_length(sz, max);
    Ensures(sz[len] == 0);
    return span<const wchar_t, dynamic_extent>(sz, len);
}

template <typename T, size_t N>
span<T, dynamic_extent> ensure_z(T (&sz)[N])
{
    return ensure_z(&sz[0], static_cast<std::ptrdiff_t>(N));
}

template <class Cont>
span<typename boost::remove_pointer<typename Cont::pointer>::type, dynamic_extent>
ensure_z(Cont& cont)
{
    return ensure_z(cont.data(), static_cast<std::ptrdiff_t>(cont.length()));
}

template <typename CharT, std::ptrdiff_t>
class basic_string_span;

namespace details
{
    template <typename T>
    struct is_basic_string_span_oracle : boost::false_type
    {
    };

    template <typename CharT, std::ptrdiff_t Extent>
    struct is_basic_string_span_oracle<basic_string_span<CharT, Extent> > : boost::true_type
    {
    };

    template <typename T>
    struct is_basic_string_span : is_basic_string_span_oracle<typename boost::remove_cv<T>::type >
    {
    };

    template <typename T>
    struct length_func
    {
    };

    template <>
    struct length_func<char>
    {
        std::ptrdiff_t operator()(char* const ptr, std::ptrdiff_t length) GSL_NOEXCEPT
        {
            return details::string_length(ptr, length);
        }
    };

    template <>
    struct length_func<wchar_t>
    {
        std::ptrdiff_t operator()(wchar_t* const ptr, std::ptrdiff_t length) GSL_NOEXCEPT
        {
            return details::wstring_length(ptr, length);
        }
    };

    template <>
    struct length_func<const char>
    {
        std::ptrdiff_t operator()(const char* const ptr, std::ptrdiff_t length) GSL_NOEXCEPT
        {
            return details::string_length(ptr, length);
        }
    };

    template <>
    struct length_func<const wchar_t>
    {
        std::ptrdiff_t operator()(const wchar_t* const ptr, std::ptrdiff_t length) GSL_NOEXCEPT
        {
            return details::wstring_length(ptr, length);
        }
    };
}

//
// string_span and relatives
//
template <typename CharT, std::ptrdiff_t Extent = dynamic_extent>
class basic_string_span
{
  BOOST_COPYABLE_AND_MOVABLE(basic_string_span)

public:
    typedef CharT element_type;
    typedef typename boost::add_pointer<element_type>::type pointer;
    typedef typename boost::add_lvalue_reference<element_type>::type reference;
    typedef typename boost::add_lvalue_reference<typename boost::add_const<element_type>::type >::type const_reference;
    typedef span<element_type, Extent> impl_type;

    typedef typename impl_type::index_type index_type;
    typedef typename impl_type::iterator iterator;
    typedef typename impl_type::const_iterator const_iterator;
    typedef typename impl_type::reverse_iterator reverse_iterator;
    typedef typename impl_type::const_reverse_iterator const_reverse_iterator;

    // default (empty)
    BOOST_DEFAULTED_FUNCTION( GSL_CONSTEXPR basic_string_span() GSL_NOEXCEPT, : span_() {});

    // copy
    BOOST_DEFAULTED_FUNCTION( GSL_CONSTEXPR basic_string_span(const basic_string_span& other) GSL_NOEXCEPT, : span_(other.span_) {});

// move
    BOOST_DEFAULTED_FUNCTION(GSL_CONSTEXPR basic_string_span(BOOST_RV_REF(basic_string_span) other), : span_(boost::move(other.span_)) {})

    // assign
    BOOST_DEFAULTED_FUNCTION( GSL_DEFAULT_CONSTEXPR basic_string_span& operator=(BOOST_COPY_ASSIGN_REF(basic_string_span) other) GSL_NOEXCEPT, 
    {
        span_ = other.span_;
        return *this;
    }
    )

// move assign
    BOOST_DEFAULTED_FUNCTION(
    GSL_CONSTEXPR basic_string_span& operator=(BOOST_RV_REF(basic_string_span) other) GSL_NOEXCEPT,
    {
        span_ = boost::move(other.span_);
        return *this;
    }
    )

    // from nullptr
    GSL_CONSTEXPR basic_string_span(stdex::nullptr_t ptr) GSL_NOEXCEPT : span_(ptr) {}

    GSL_CONSTEXPR basic_string_span(pointer ptr, index_type length) : span_(ptr, length) {}
    GSL_CONSTEXPR basic_string_span(pointer firstElem, pointer lastElem) : span_(firstElem, lastElem) {}

    // From static arrays - if 0-terminated, remove 0 from the view
    // All other containers allow 0s within the length, so we do not remove them
    template <size_t N>
    GSL_CONSTEXPR basic_string_span(element_type (&arr)[N]) : span_(remove_z(arr))
    {
    }

#if __cplusplus >= 201102L
    template <size_t N, class ArrayElementType>
    GSL_CONSTEXPR basic_string_span(std::array<ArrayElementType, N>& arr) GSL_NOEXCEPT : span_(arr)
    {
    }
    template <size_t N>
    GSL_CONSTEXPR basic_string_span(std::array<typename boost::remove_const<element_type>::type, N>& arr) GSL_NOEXCEPT : span_(arr)
    {
    }

    template <size_t N, class ArrayElementType >
    GSL_CONSTEXPR basic_string_span(const std::array<ArrayElementType, N>& arr) GSL_NOEXCEPT : span_(arr)
    {
    }
    template <size_t N>
    GSL_CONSTEXPR basic_string_span(const std::array<typename boost::remove_const<element_type>::type, N>& arr) GSL_NOEXCEPT : span_(arr)
    {
    }

#endif
    GSL_CONSTEXPR basic_string_span(impl_type s) GSL_NOEXCEPT : span_(s)
    {
    }

    // Container signature should work for basic_string after C++17 version exists
    template <class Traits, class Allocator>
    GSL_CONSTEXPR basic_string_span(std::basic_string<element_type, Traits, Allocator>& str)
        : span_(&str[0], narrow_cast<std::ptrdiff_t>(str.length()))
    {
    }

    template <class Traits, class Allocator>
    GSL_CONSTEXPR basic_string_span(const std::basic_string<element_type, Traits, Allocator>& str)
        : span_(&str[0], str.length())
    {
    }

    // from containers. Containers must have a pointer type and data() function signatures
    template <class Container>
    GSL_CONSTEXPR basic_string_span(Container& cont,
              typename boost::enable_if_c<
                  !details::is_basic_string_span<Container>::value &&
                  boost::is_convertible<typename Container::pointer, pointer>::value
#if ! defined BOOST_NO_CXX11_DECLTYPE                  
                  &&
                  boost::is_convertible<typename Container::pointer,
                                      decltype(boost::declval<Container>().data())>::value
#endif
              >::type* = 0
      ) : span_(cont)
    {
    }

    template <class Container>
    GSL_CONSTEXPR basic_string_span(const Container& cont,
      typename boost::enable_if_c<
                  !details::is_basic_string_span<Container>::value &&
                  boost::is_convertible<typename Container::pointer, pointer>::value 
#if ! defined BOOST_NO_CXX11_DECLTYPE                  
                  &&
                  boost::is_convertible<typename Container::pointer,
                                      decltype(boost::declval<Container>().data())>::value
#endif        
      >::type * = 0
    ) : span_(cont)
    {
    }

    // from string_span
    template <
        class OtherValueType, std::ptrdiff_t OtherExtent>
    GSL_CONSTEXPR basic_string_span(basic_string_span<OtherValueType, OtherExtent> other,
      typename boost::enable_if_c<
        boost::is_convertible<
            typename basic_string_span<OtherValueType, OtherExtent>::impl_type, impl_type
        >::value
      >::type * = 0     
    )
        : span_(other.data(), other.length())
    {
    }
    
    template <index_type Count>
    GSL_CONSTEXPR basic_string_span<element_type, Count> first() const
    {
        return basic_string_span<element_type, Count>(span_.template first<Count>());
    }

    GSL_CONSTEXPR basic_string_span<element_type, dynamic_extent> first(index_type count) const
    {
        return basic_string_span<element_type, dynamic_extent>(span_.first(count));
    }

    template <index_type Count>
    GSL_CONSTEXPR basic_string_span<element_type, Count> last() const
    {
        return basic_string_span<element_type, Count>(span_.template last<Count>());
    }

    GSL_CONSTEXPR basic_string_span<element_type, dynamic_extent> last(index_type count) const
    {
        return basic_string_span<element_type, dynamic_extent>(span_.last(count));
    }

    template <index_type Offset, index_type Count>
    GSL_CONSTEXPR basic_string_span<element_type, Count> subspan() const
    {
        return basic_string_span<element_type, Count>(span_.template subspan<Offset, Count>());
    }

    GSL_CONSTEXPR basic_string_span<element_type, dynamic_extent>
    subspan(index_type offset, index_type count = dynamic_extent) const
    {
        return basic_string_span<element_type, dynamic_extent>(span_.subspan(offset, count));
    }

    GSL_CONSTEXPR reference operator[](index_type idx) const { return span_[idx]; }
    GSL_CONSTEXPR reference operator()(index_type idx) const { return span_[idx]; }

    GSL_CONSTEXPR pointer data() const { return span_.data(); }

    GSL_CONSTEXPR index_type length() const GSL_NOEXCEPT { return span_.size(); }
    GSL_CONSTEXPR index_type size() const GSL_NOEXCEPT { return span_.size(); }
    GSL_CONSTEXPR index_type size_bytes() const GSL_NOEXCEPT { return span_.size_bytes(); }
    GSL_CONSTEXPR index_type length_bytes() const GSL_NOEXCEPT { return span_.length_bytes(); }
    GSL_CONSTEXPR bool empty() const GSL_NOEXCEPT { return size() == 0; }

    GSL_CONSTEXPR iterator begin() const GSL_NOEXCEPT { return span_.begin(); }
    GSL_CONSTEXPR iterator end() const GSL_NOEXCEPT { return span_.end(); }

    GSL_CONSTEXPR const_iterator cbegin() const GSL_NOEXCEPT { return span_.cbegin(); }
    GSL_CONSTEXPR const_iterator cend() const GSL_NOEXCEPT { return span_.cend(); }

    GSL_CONSTEXPR reverse_iterator rbegin() const GSL_NOEXCEPT { return span_.rbegin(); }
    GSL_CONSTEXPR reverse_iterator rend() const GSL_NOEXCEPT { return span_.rend(); }

    GSL_CONSTEXPR const_reverse_iterator crbegin() const GSL_NOEXCEPT { return span_.crbegin(); }
    GSL_CONSTEXPR const_reverse_iterator crend() const GSL_NOEXCEPT { return span_.crend(); }

private:
    static impl_type remove_z(pointer const& sz, std::ptrdiff_t max)
    {
        return impl_type(sz, details::length_func<element_type>()(sz, max));
    }

    template <size_t N>
    static impl_type remove_z(element_type (&sz)[N])
    {
        return remove_z(&sz[0], narrow_cast<std::ptrdiff_t>(N));
    }

    impl_type span_;
};

//fixme
#if ! defined BOOST_NO_CXX11_TEMPLATE_ALIASES
template <std::ptrdiff_t Extent = dynamic_extent>
using string_span = basic_string_span<char, Extent>;

template <std::ptrdiff_t Extent = dynamic_extent>
using cstring_span = basic_string_span<const char, Extent>;

template <std::ptrdiff_t Extent = dynamic_extent>
using wstring_span = basic_string_span<wchar_t, Extent>;

template <std::ptrdiff_t Extent = dynamic_extent>
using cwstring_span = basic_string_span<const wchar_t, Extent>;

#else

template <std::ptrdiff_t Extent = dynamic_extent>
struct string_span { typedef basic_string_span<char, Extent> type;};

template <std::ptrdiff_t Extent = dynamic_extent>
struct cstring_span { typedef  basic_string_span<const char, Extent> type;};

template <std::ptrdiff_t Extent = dynamic_extent>
struct wstring_span { typedef  basic_string_span<wchar_t, Extent> type;};

template <std::ptrdiff_t Extent = dynamic_extent>
struct cwstring_span { typedef  basic_string_span<const wchar_t, Extent> type;};

#endif
//
// to_string() allow (explicit) conversions from string_span to string
//
#ifndef GSL_MSVC_HAS_TYPE_DEDUCTION_BUG

template <typename CharT, std::ptrdiff_t Extent>
std::basic_string<typename boost::remove_const<CharT>::type>
to_string(basic_string_span<CharT, Extent> view)
{
    return std::basic_string<typename boost::remove_const<CharT>::type>(view.data(), static_cast<size_t>(view.length()));
}

#else

inline std::string to_string(cstring_span<> view)
{
    return {view.data(), static_cast<size_t>(view.length())};
}

inline std::string to_string(string_span<> view)
{
    return {view.data(), static_cast<size_t>(view.length())};
}

inline std::wstring to_string(cwstring_span<> view)
{
    return {view.data(), static_cast<size_t>(view.length())};
}

inline std::wstring to_string(wstring_span<> view)
{
    return {view.data(), static_cast<size_t>(view.length())};
}

#endif

template <typename CharT,
	  typename Traits = typename std::char_traits<CharT>,
	  typename Allocator = std::allocator<CharT>,
	  typename gCharT,
	  std::ptrdiff_t Extent>
std::basic_string<CharT, Traits, Allocator> to_basic_string(basic_string_span<gCharT, Extent> view)
{
  return {view.data(), static_cast<size_t>(view.length())};
}
  
// zero-terminated string span, used to convert
// zero-terminated spans to legacy strings
template <typename CharT, std::ptrdiff_t Extent = dynamic_extent>
class basic_zstring_span
{
  BOOST_COPYABLE_AND_MOVABLE(basic_zstring_span)

public:
    typedef CharT value_type;
    typedef typename boost::add_const<CharT>::type const_value_type;

    typedef typename boost::add_pointer<value_type>::type pointer;
    typedef typename boost::add_pointer<const_value_type>::type const_pointer;

    typedef typename basic_zstring<value_type, Extent>::type zstring_type;
    typedef typename basic_zstring<const_value_type, Extent>::type const_zstring_type;

    typedef span<value_type, Extent> impl_type;
    typedef basic_string_span<value_type, Extent> string_span_type;

    GSL_CONTRACT_CONSTEXPR basic_zstring_span(impl_type s) GSL_NOEXCEPT : span_(s)
    {
        // expects a zero-terminated span
        Expects(s[s.size() - 1] == '\0');
    }

    // copy
    BOOST_DEFAULTED_FUNCTION( GSL_CONSTEXPR basic_zstring_span(const basic_zstring_span& other), : span_(other.span_) {});

// move
    BOOST_DEFAULTED_FUNCTION( GSL_CONSTEXPR basic_zstring_span(BOOST_RV_REF(basic_zstring_span) other), 
        : span_(boost::move(other.span_)) {}
    )

    // assign
    BOOST_DEFAULTED_FUNCTION( GSL_DEFAULT_CONSTEXPR basic_zstring_span& operator=(BOOST_COPY_ASSIGN_REF(basic_zstring_span) other), 
    {
        span_ = other.span_;
        return *this;
    }
    )

// move assign
    BOOST_DEFAULTED_FUNCTION( GSL_CONSTEXPR basic_zstring_span& operator=(BOOST_RV_REF(basic_zstring_span) other),
    {
        span_ = boost::move(other.span_);
        return *this;
    }
    )

    GSL_CONSTEXPR bool empty() const GSL_NOEXCEPT { return span_.size() == 0; }

    GSL_CONSTEXPR string_span_type as_string_span() const GSL_NOEXCEPT
    {
        auto sz = span_.size();
        return span_.first(sz <= 0 ? 0 : sz - 1);
    }

    GSL_CONSTEXPR string_span_type ensure_z() const GSL_NOEXCEPT { return gsl::ensure_z(span_); }

    GSL_CONSTEXPR const_zstring_type assume_z() const GSL_NOEXCEPT { return span_.data(); }

private:
    impl_type span_;
};

#if ! defined BOOST_NO_CXX11_TEMPLATE_ALIASES

template <std::ptrdiff_t Max = dynamic_extent>
using zstring_span = basic_zstring_span<char, Max>;

template <std::ptrdiff_t Max = dynamic_extent>
using wzstring_span = basic_zstring_span<wchar_t, Max>;

template <std::ptrdiff_t Max = dynamic_extent>
using czstring_span = basic_zstring_span<const char, Max>;

template <std::ptrdiff_t Max = dynamic_extent>
using cwzstring_span = basic_zstring_span<const wchar_t, Max>;

#else

template <std::ptrdiff_t Max = dynamic_extent>
struct zstring_span { typedef basic_zstring_span<char, Max> type; };

template <std::ptrdiff_t Max = dynamic_extent>
struct wzstring_span  { typedef  basic_zstring_span<wchar_t, Max> type; };

template <std::ptrdiff_t Max = dynamic_extent>
struct czstring_span  { typedef  basic_zstring_span<const char, Max> type; };

template <std::ptrdiff_t Max = dynamic_extent>
struct cwzstring_span  { typedef  basic_zstring_span<const wchar_t, Max> type; };

#endif
// operator ==
template <class CharT, std::ptrdiff_t Extent, class T>
typename boost::enable_if_c<
              details::is_basic_string_span<T>::value ||
              boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>::type > >::value, 
bool>::type operator==(const gsl::basic_string_span<CharT, Extent>& one, const T& other) GSL_NOEXCEPT
{
    gsl::basic_string_span<typename boost::add_const<CharT>::type > tmp(other);
#ifdef GSL_MSVC_NO_CPP14_STD_EQUAL
    return (one.size() == tmp.size()) && std::equal(one.begin(), one.end(), tmp.begin());
#else
    return stdex::equal(one.begin(), one.end(), tmp.begin(), tmp.end());
#endif
}

template <class CharT, std::ptrdiff_t Extent, class T>
typename boost::enable_if_c<
              !details::is_basic_string_span<T>::value &&
              boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>::type > >::value,
bool>::type operator==(const T& one, const gsl::basic_string_span<CharT, Extent>& other) GSL_NOEXCEPT
{
    gsl::basic_string_span<typename boost::add_const<CharT>::type > tmp(one);
#ifdef GSL_MSVC_NO_CPP14_STD_EQUAL
    return (tmp.size() == other.size()) && std::equal(tmp.begin(), tmp.end(), other.begin());
#else
    return stdex::equal(tmp.begin(), tmp.end(), other.begin(), other.end());
#endif
}

// operator !=
template <typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<boost::is_convertible<
              T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value,
bool>::type operator!=(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return !(one == other);
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value &&
        !gsl::details::is_basic_string_span<T>::value, 
bool>::type operator!=(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return !(one == other);
}

// operator<
template <typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<boost::is_convertible<
              T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value,
bool>::type operator<(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> tmp(other);
    return std::lexicographical_compare(one.begin(), one.end(), tmp.begin(), tmp.end());
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value &&
        !gsl::details::is_basic_string_span<T>::value,    
bool>::type operator<(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> tmp(one);
    return std::lexicographical_compare(tmp.begin(), tmp.end(), other.begin(), other.end());
}

#ifndef _MSC_VER

// VS treats temp and const containers as convertible to basic_string_span,
// so the cases below are already covered by the previous operators

//fixme
//#if ! defined BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS

template <
    typename CharT, std::ptrdiff_t Extent, typename T>

typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype(boost::declval<T>().size(), *boost::declval<T>().data())>::type,
                     typename T::value_type>::value
#endif
,
bool >::type operator<(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> tmp(other);
    return std::lexicographical_compare(one.begin(), one.end(), tmp.begin(), tmp.end());
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype(boost::declval<T>().size(), *boost::declval<T>().data())>::type,
                     typename T::value_type>::value
#endif                     
,
bool>::type operator<(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> tmp(one);
    return std::lexicographical_compare(tmp.begin(), tmp.end(), other.begin(), other.end());
}
//#endif
#endif

// operator <=
template <typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<boost::is_convertible<
              T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value,
bool>::type operator<=(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return !(other < one);
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value &&
        !gsl::details::is_basic_string_span<T>::value,
bool>::type operator<=(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return !(other < one);
}

#ifndef _MSC_VER

// VS treats temp and const containers as convertible to basic_string_span,
// so the cases below are already covered by the previous operators

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype((boost::declval<T>().size(), *boost::declval<T>().data()))>::type,
                     typename T::value_type>::value
#endif
,
bool>::type operator<=(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return !(other < one);
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype((boost::declval<T>().size(), *boost::declval<T>().data()))>::type,
                     typename T::value_type>::value

#endif
,
bool>::type operator<=(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return !(other < one);
}
#endif

// operator>
template <typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<boost::is_convertible<
              T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value,
bool>::type operator>(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return other < one;
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>, Extent> >::value &&
        !gsl::details::is_basic_string_span<T>::value,
bool>::type operator>(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return other < one;
}

#ifndef _MSC_VER

// VS treats temp and const containers as convertible to basic_string_span,
// so the cases below are already covered by the previous operators

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype((boost::declval<T>().size(), *boost::declval<T>().data()))>::type,
                     typename T::value_type>::value
#endif
,
bool>::type operator>(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return other < one;
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype((boost::declval<T>().size(), *boost::declval<T>().data()))>::type,
                     typename T::value_type>::value
#endif                     
,
bool>::type operator>(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return other < one;
}
#endif

// operator >=
template <typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<boost::is_convertible<
              T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value,
bool>::type operator>=(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return !(one < other);
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        boost::is_convertible<T, gsl::basic_string_span<typename boost::add_const<CharT>::type, Extent> >::value &&
        !gsl::details::is_basic_string_span<T>::value,
bool>::type operator>=(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return !(one < other);
}

#ifndef _MSC_VER

// VS treats temp and const containers as convertible to basic_string_span,
// so the cases below are already covered by the previous operators

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE
        &&
        boost::is_same<typename boost::decay<decltype((boost::declval<T>().size(), *boost::declval<T>().data()))>::type,
                     typename T::value_type>::value
#endif                     
,
bool>::type operator>=(gsl::basic_string_span<CharT, Extent> one, const T& other) GSL_NOEXCEPT
{
    return !(one < other);
}

template <
    typename CharT, std::ptrdiff_t Extent, typename T>
typename boost::enable_if_c<
        !gsl::details::is_span<T>::value && !gsl::details::is_basic_string_span<T>::value &&
        boost::is_convertible<typename T::value_type*, CharT*>::value 
// fixme
#if ! defined BOOST_NO_CXX11_DECLTYPE        
        &&
        boost::is_same<typename boost::decay<decltype((boost::declval<T>().size(), *boost::declval<T>().data()))>::type,
                     typename T::value_type>::value
#endif
,
bool>::type operator>=(const T& one, gsl::basic_string_span<CharT, Extent> other) GSL_NOEXCEPT
{
    return !(one < other);
}
#endif
} // namespace GSL

#ifdef _MSC_VER

#pragma warning(pop)

#undef constexpr
#pragma pop_macro("constexpr")

// VS 2013 workarounds
#if _MSC_VER <= 1800

#ifndef GSL_THROW_ON_CONTRACT_VIOLATION
#undef noexcept
#pragma pop_macro("noexcept")
#endif // GSL_THROW_ON_CONTRACT_VIOLATION

#undef GSL_MSVC_HAS_TYPE_DEDUCTION_BUG
#undef GSL_MSVC_HAS_SFINAE_SUBSTITUTION_ICE
#undef GSL_MSVC_NO_CPP14_STD_EQUAL
#undef GSL_MSVC_NO_DEFAULT_MOVE_CTOR

#endif // _MSC_VER <= 1800
#endif // _MSC_VER

#if defined(GSL_THROW_ON_CONTRACT_VIOLATION)

#undef noexcept

#ifdef _MSC_VER
#pragma pop_macro("noexcept")
#endif

#endif // GSL_THROW_ON_CONTRACT_VIOLATION
#endif // GSL_STRING_SPAN_H
