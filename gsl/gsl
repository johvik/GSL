///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef GSL_GSL_H
#define GSL_GSL_H

#include "gsl_config.hpp"
#include <gsl/stdex/nullptr.hpp>
#include <boost/type_traits.hpp>
#include <boost/static_assert.hpp>
#include "stdex/type_traits.hpp"
#include <boost/thread/csbl/memory/unique_ptr.hpp>

#include "gsl_assert"  // Ensures/Expects
#include "gsl_util"    // finally()/narrow()/narrow_cast()...
#include "multi_span"  // multi_span, strided_span...
#include "span"        // span
#include "string_span" // zstring, string_span, zstring_builder...
#include <memory>
#include <boost/functional/hash.hpp>

#ifdef _MSC_VER

// No MSVC does constexpr fully yet
#pragma push_macro("constexpr")
#define constexpr /*constexpr*/

// MSVC 2013 workarounds
#if _MSC_VER <= 1800
// noexcept is not understood
#pragma push_macro("noexcept")
#define noexcept /*noexcept*/

// turn off some misguided warnings
#pragma warning(push)
#pragma warning(disable : 4351) // warns about newly introduced aggregate initializer behavior

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

namespace gsl
{

//
// GSL.owner: ownership pointers
//
using boost::csbl::unique_ptr;
using boost::shared_ptr;


#if ! defined BOOST_NO_CXX11_TEMPLATE_ALIASES
template <class T>
using owner = T;

#define GSL_OWNER(T) ::gsl::owner<T>
#define GSL_OWNER_T(T) ::gsl::owner<T>

#else
template <class T>
struct owner {
  typedef T type;
};

#define GSL_OWNER(T) ::gsl::owner<T>::type
#define GSL_OWNER_T(T) typename ::gsl::owner<T>::type

#endif
//
// not_null
//
// Restricts a pointer or smart pointer to only hold non-null values.
//
// Has zero size overhead over T.
//
// If T is a pointer (i.e. T == U*) then
// - allow construction from U* or U&
// - disallow construction from nullptr_t
// - disallow default construction
// - ensure construction from U* fails with nullptr
// - allow implicit conversion to U*
//
template <class T>
class not_null
{
#if __cplusplus >= 201102L
// fixme: Why it is not assignable?
    BOOST_STATIC_ASSERT_MSG((boost::is_assignable<T&, stdex::nullptr_t>::value), "T cannot be assigned nullptr.");
#else
#if defined GSL_NULLPTR_IS_A_STRONG_TYPE
    BOOST_STATIC_ASSERT_MSG((boost::is_convertible<stdex::nullptr_t, T>::value), "nullptr_t cannot be converted to T.");
#endif
#endif
public:
    not_null(T t) : ptr_(t) { ensure_invariant(); }
    not_null& operator=(const T& t)
    {
        ptr_ = t;
        ensure_invariant();
        return *this;
    }

    BOOST_DEFAULTED_FUNCTION( not_null(const not_null& other), : ptr_(other.ptr_){});
    BOOST_DEFAULTED_FUNCTION(not_null& operator=(const not_null& other), {
      ptr_=other.ptr_; return *this;
    });

    template <typename U>
    not_null(const not_null<U>& other, typename boost::enable_if_c<boost::is_convertible<U, T>::value>::type * = 0)
    {
        *this = other;
    }

    template <typename U>
    typename boost::enable_if_c<boost::is_convertible<U, T>::value, not_null&>::type operator=(const not_null<U>& other)
    {
        ptr_ = other.get();
        return *this;
    }

    // prevents compilation when someone attempts to assign a nullptr
    BOOST_DELETED_FUNCTION(not_null(stdex::nullptr_t))
    BOOST_DELETED_FUNCTION(not_null(int))
    BOOST_DELETED_FUNCTION(not_null<T>& operator=(stdex::nullptr_t))
    BOOST_DELETED_FUNCTION(not_null<T>& operator=(int))

public:
    T get() const
    {
#ifdef _MSC_VER
        __assume(ptr_ != NULLPTR);
#endif
        return ptr_;
    } // the assume() should help the optimizer

    operator T() const { return get(); }
    T operator->() const { return get(); }

    bool operator==(const T& rhs) const { return ptr_ == rhs; }
    bool operator!=(const T& rhs) const { return !(*this == rhs); }
private:
    T ptr_;

    // we assume that the compiler can hoist/prove away most of the checks inlined from this
    // function
    // if not, we could make them optional via conditional compilation
    void ensure_invariant() const { Expects(ptr_ != NULLPTR); }

    // unwanted operators...pointers only point to single objects!
    // TODO ensure all arithmetic ops on this type are unavailable
    BOOST_DELETED_FUNCTION(not_null<T>& operator++())
    BOOST_DELETED_FUNCTION(not_null<T>& operator--())
    BOOST_DELETED_FUNCTION(not_null<T> operator++(int))
    BOOST_DELETED_FUNCTION(not_null<T> operator--(int))
    BOOST_DELETED_FUNCTION(not_null<T>& operator+(size_t))
    BOOST_DELETED_FUNCTION(not_null<T>& operator+=(size_t))
    BOOST_DELETED_FUNCTION(not_null<T>& operator-(size_t))
    BOOST_DELETED_FUNCTION(not_null<T>& operator-=(size_t))
};

} // namespace gsl

namespace boost
{
template <class T>
struct hash<gsl::not_null<T> >
{
    size_t operator()(const gsl::not_null<T>& value) const { return hash<T>()(value); }
};

} // namespace boost

#ifdef _MSC_VER

#undef constexpr
#pragma pop_macro("constexpr")

#if _MSC_VER <= 1800

#undef noexcept
#pragma pop_macro("noexcept")

#pragma warning(pop)

#endif // _MSC_VER <= 1800

#endif // _MSC_VER

#endif // GSL_GSL_H
